
// === PRACTICA 01 - PROGRAMACION WEB III ===
// Autor: Rosset
// Fecha: 24/09/2025

// =============================
// 1) Contar vocales
// =============================
function contarVocales(texto) {
  const mapa = {};
  if (!texto) return mapa;
  const lower = texto.toLowerCase();
  const vocales = 'aeiouáéíóúü';

  for (const ch of lower) {
    if (vocales.includes(ch)) {
      const base = ch.normalize ? ch.normalize('NFD').replace(/[̀-\u036f]/g, '') : ch;
      mapa[base] = (mapa[base] || 0) + 1;
    }
  }
  return mapa;
}
console.log(contarVocales("euforia")); // { e:1, u:1, o:1, i:1, a:1 }

// =============================
// 2) Invertir cadena y palabras
// =============================
function invertirCadena(str) {
  return str.split('').reverse().join('');
}
console.log(invertirCadena("abcd")); // "dcba"

function invertirPalabras(frase) {
  return frase.split(' ').filter(Boolean).reverse().join(' ');
}
console.log(invertirPalabras("Hola mundo esto es prueba"));

// =============================
// 3) Pares e impares
// =============================
function paresEimpares(arr) {
  const result = { pares: [], impares: [] };
  for (const n of arr) {
    if (typeof n !== 'number' || Number.isNaN(n)) continue;
    if (n % 2 === 0) result.pares.push(n);
    else result.impares.push(n);
  }
  return result;
}
console.log(paresEimpares([1,2,3,4,5]));

// =============================
// 4) Mayor y menor
// =============================
function mayorYmenor(arr) {
  if (!Array.isArray(arr) || arr.length === 0) return { mayor: null, menor: null };
  const nums = arr.filter(x => typeof x === 'number' && !Number.isNaN(x));
  if (nums.length === 0) return { mayor: null, menor: null };
  return { mayor: Math.max(...nums), menor: Math.min(...nums) };
}
console.log(mayorYmenor([3,1,5,4,2]));

// =============================
// 5) Palíndromo
// =============================
function esPalindromo(str) {
  if (typeof str !== 'string') return false;
  const normal = str
    .toLowerCase()
    .normalize('NFD').replace(/[̀-\u036f]/g, '')
    .replace(/[^a-z0-9]/g, '');
  const inv = normal.split('').reverse().join('');
  return normal === inv;
}
console.log(esPalindromo("oruro")); // true
console.log(esPalindromo("hola"));  // false

// =============================
// 6) Desestructuración primeros
// =============================
const arr = [10, 20, 30, 40];
const [primero, segundo] = arr;
console.log(primero, segundo);

// =============================
// 7) Desestructuración resto
// =============================
const arr2 = [1,2,3,4,5];
const [a, b, ...resto] = arr2;
console.log(a, b);
console.log(resto);

// =============================
// 8) Callback después de 2s
// =============================
function ejecutarDespuesDe2s(callback, ...args) {
  setTimeout(() => {
    if (typeof callback === 'function') callback(...args);
  }, 2000);
}
ejecutarDespuesDe2s((msg) => console.log("Callback ejecutado:", msg), "hola");

// =============================
// 9) Promesa éxito después de 3s
// =============================
function promesaExito3s() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("¡Éxito después de 3 segundos!"), 3000);
  });
}
promesaExito3s().then(msg => console.log(msg));

// =============================
// 10) Cuándo usar callback/promesa
// =============================
// (Explicación en informe)

// =============================
// 11) Encadenamiento de promesas
// =============================
function paso1() { return Promise.resolve(2); }
function paso2(x) { return Promise.resolve(x * 3); }
function paso3(x) { return Promise.resolve(x + 5); }

paso1()
  .then(r1 => paso2(r1))
  .then(r2 => paso3(r2))
  .then(final => console.log("Resultado final:", final));

// =============================
// 12) Callbacks -> async/await
// =============================
function tarea1(cb){ setTimeout(()=> cb(null, 'A'), 300); }
function tarea2(prev, cb){ setTimeout(()=> cb(null, prev + 'B'), 300); }
function tarea3(prev, cb){ setTimeout(()=> cb(null, prev + 'C'), 300); }

tarea1((err, r1) => {
  if (err) return console.error(err);
  tarea2(r1, (err, r2) => {
    if (err) return console.error(err);
    tarea3(r2, (err, r3) => {
      if (err) return console.error(err);
      console.log('Resultado callback:', r3);
    });
  });
});

const pTarea1 = () => new Promise(res => setTimeout(()=> res('A'), 300));
const pTarea2 = prev => new Promise(res => setTimeout(()=> res(prev + 'B'), 300));
const pTarea3 = prev => new Promise(res => setTimeout(()=> res(prev + 'C'), 300));

(async function run() {
  const r1 = await pTarea1();
  const r2 = await pTarea2(r1);
  const r3 = await pTarea3(r2);
  console.log('Resultado async/await:', r3);
})();

// =============================
// 13) Promesas -> async/await
// =============================
function sumaAsync(x) { return Promise.resolve(x + 1); }

sumaAsync(1)
  .then(r => sumaAsync(r))
  .then(r => sumaAsync(r))
  .then(final => console.log("then final:", final));

(async function() {
  let v = await sumaAsync(1);
  v = await sumaAsync(v);
  v = await sumaAsync(v);
  console.log("async/await final:", v);
})();

// =============================
// 14) Promesa -> callback
// =============================
function promesaAcallback(promesaFn, callback) {
  promesaFn()
    .then(result => callback(null, result))
    .catch(err => callback(err));
}
promesaAcallback(promesaExito3s, (err, res) => {
  if (err) console.error("Error callback:", err);
  else console.log("Resultado via callback:", res);
});

// =============================
// 15) Callback -> promesa
// =============================
function promisify(fnConCallback) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      fnConCallback(...args, (err, res) => {
        if (err) reject(err);
        else resolve(res);
      });
    });
  };
}
function duplicarCallback(x, cb) {
  setTimeout(()=> cb(null, x * 2), 200);
}
const duplicarPromesa = promisify(duplicarCallback);
duplicarPromesa(5).then(res => console.log("duplicarPromesa:", res));

// =============================
// 16) Migrar promesas a async/await
// =============================
function obtenerYProcesar() {
  return promesaExito3s()
    .then(msg => Promise.resolve(msg + " -> procesado"))
    .then(final => final);
}
obtenerYProcesar().then(r => console.log("antes:", r));

async function obtenerYprocesarAsync() {
  const msg = await promesaExito3s();
  const final = await Promise.resolve(msg + " -> procesado");
  return final;
}
(async () => {
  const r = await obtenerYprocesarAsync();
  console.log("después async/await:", r);
})();
